# -*- coding: utf-8 -*-
"""Projeto_de_analise_1ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sNLvAXEUyDeO2eVKdu52BESR7UCQWJNn

MODULOS
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.dummy import DummyClassifier
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.dummy import DummyRegressor
import matplotlib.pyplot as plt
from sklearn.model_selection import cross_validate
from sklearn.model_selection import KFold
from sklearn.model_selection import GroupKFold
from sklearn import linear_model
from sklearn.pipeline import Pipeline
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
# %matplotlib inline
from sklearn.feature_selection import RFE, f_regression
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.datasets import make_regression
from sklearn.metrics import accuracy_score
from sklearn.neighbors import KNeighborsRegressor

def imprime_resultados(resultados):
    media = resultados['test_score'].mean()
    desvio_padrao = resultados['test_score'].std()  
    print(f'a faixa da acuracia fica {((media - 2 * desvio_padrao)*100):.2f}% até {((media + 2 * desvio_padrao)*100):.2f}%')

"""CARREGANDO DATA"""

dados = pd.read_csv('/content/kc_house_data.csv')
dados.head()

renomear = {
    'id':'identificaçâo',
    'date':'data',
    'price':'preco',
    'bedrooms':'dormitorios',
    'sqft_living':'metro_quadrado',
    'sqft_lot':'metragem_quadrada_do_lote',
    'floors':'pisos',
    'waterfront':'fonte_de_agua',
    'view':'visâo',
    'codition':'condição',
    'grade':'avaliação',
    'sqft_above':'metragem_quadrada_da_casa_além_do_porão',
    'sqft_basement':'metragem_quadrada_do_porão',
    'lat':'Cordenada_de_latitude',
    'long':'Cordenada_de_longitude',
    'sqft_living15':'Área_da_sala_de_estar_em_2015',
    'yr_built':'Ano_de_construção',
    'yr_renovated':'Ano_de_renovação',
    'zipcode':'zip_code',
    'sqft_lot15':'Área_do_tamanho_do_lote_em_2015(implicando-reformas)',
    'bathrooms':'banheiros'
}

dados.rename(mapper = renomear, axis=1, inplace=True)
dados.head(5)

"""PROCURANDO VALORES NULOS"""

print(dados.isnull().any())
print(dados.dtypes)

dados = dados.drop(['identificaçâo', 'data'],axis=1)

dados.head(5)

"""PAIRPLOT PARA VISUALIZAÇÃO"""

#divisão por quantia de dormitorios
sns.pairplot(dados[['preco', 'metro_quadrado', 'metragem_quadrada_do_lote', 'banheiros','dormitorios']],
             hue='dormitorios',palette='tab20')

"""CORRELAÇÃO"""

correlacao = dados.corr()
plt.figure(figsize= (15, 15))
sns.set(font_scale=1)
sns.heatmap(correlacao, annot=True ,fmt='.1f')

"""COMPARAÇÃO METRAGEM EM RELAÇÃO AO PREÇO"""

sns.scatterplot(x = 'metro_quadrado', y = 'preco', data=dados)

"""metodo Train_test_split"""

x = dados.iloc[:,1:].values
y = dados.iloc[:,0].values

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 1/3, random_state = 0)

"""IMPLEMENTANDO O MODELO LARSCV() com CROSS VALIDATE"""

scaler_SS = StandardScaler()
scaler_SS.fit(x_train)

SEED = 123
np.random.seed(SEED)

cv = KFold(n_splits=15,shuffle=True)

regressor = linear_model.LarsCV(cv = cv)

pipeline = Pipeline([('scaler', scaler_SS), ('regressor', regressor)])

resultado = cross_validate(pipeline, x_test, y_test, cv=cv, return_train_score=False)

imprime_resultados(resultado)

"""MIN MAX SCALER E LINEAR REGRESSION"""

scaler_MMS = MinMaxScaler()
scaler_MMS.fit_transform(dados)

regressor = LinearRegression()
regressor.fit(x_train, y_train)

y_pred = regressor.predict(x_test)
plt.scatter(x=y_test, y=y_pred, alpha=0.2)

"""RANDOM FOREST REGRESSOR"""

from sklearn.tree import export_graphviz
import graphviz

modelo = RandomForestRegressor(max_depth=2)
modelo.fit(x_train,y_train)
previsao = modelo.predict(x_test)
plt.scatter(x=y_test, y=y_pred, alpha=0.2)

x = dados.iloc[:,1:].values
y = dados.iloc[:,0].values

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size = 1/3, random_state = 0)

"""KNN REGRESSION"""

knn_r_n_neighbors = []
for i in range(1,5):
  Knn_r = KNeighborsRegressor(n_neighbors=i)

  y = Knn_r.fit(x_train, y_train)
  y_pred = Knn_r.predict(x_test)
  tabela = Knn_r.score(x_test,y_pred)

  knn_r_n_neighbors.append(tabela)

  plt.scatter(x=y_test, y=y_pred, alpha=0.2, label='1_n')
  plt.show()

resultados = pd.DataFrame(knn_r_n_neighbors,columns = ['neighbors'])

